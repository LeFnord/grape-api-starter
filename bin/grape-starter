#!/usr/bin/env ruby
# frozen_string_literal: true
$LOAD_PATH.unshift(File.join(File.dirname(__FILE__), '..', 'lib'))


require 'pry'
require 'gli'
require 'starter'

include GLI::App

program_desc 'Create initial grape api skeleton'

version Starter::VERSION

subcommand_option_handling :normal
arguments :strict

desc 'overwrites existend stuff'
switch [:f, :force], negatable: false

desc 'Create initial grape api skeleton'
arg_name 'project name'

command :new do |c|

  c.action do |global_options, _, args|
    dir = args.empty? ? nil : File.join(Dir.getwd, args.first)

    case
    when args.empty? || dir.nil?
      exit_now! 'no name given: starter new project'
    when Dir.exist?(dir) && !global_options[:force]
      exit_now! 'project exist: -f to overwrite'
    end

    $stdout.puts "created: #{args.first}"
    starter_gem = Gem::Specification.find_by_name('grape-starter').gem_dir

    src = File.join(starter_gem, 'template', '.')
    FileUtils.copy_entry src, dir

    FileUtils.cd(dir) do
      # TODO:
      $stdout.puts `bundle install`
      $stdout.puts `bundle exec rubocop -a`
      $stdout.puts `git init`
    end
  end
end

desc 'Adds a new resource - run from inside the project'
long_desc "run this command from inside the project
hereby the the given resource name
can be given in form of
'foo(s)', 'foo_bar(s)''"
arg_name 'resource [post* get* put* patch* delete*]'
command :add do |c|
  c.desc 'adds entity file'
  c.switch [:e, :entity], negatable: false

  c.action do |global_options, options, args|
    case
    when args.empty?
      exit_now! 'no resource given'
    end
    resource = args.shift
    set = args
    begin
      builder_options = global_options.merge(set: set).merge(options)
      Starter::Builder.call!(resource, builder_options)
      created_files = Starter::Builder.save

      `bundle exec rubocop -a #{created_files.join(' ')}`
      $stdout.puts "added resource: #{resource}"
    rescue => e
      exit_now! e
    end
  end
end


pre do |_global, _command, _options, _args|
  # Pre logic here
  # Return true to proceed; false to abort and not call the
  # chosen command
  # Use skips_pre before a command to skip this block
  # on that command only
  true
end

post do |global, command, options, args|
  # Post logic here
  # Use skips_post before a command to skip this
  # block on that command only
end

on_error do |_exception|
  # Error logic here
  # return false to skip default error handling
  true
end

exit run(ARGV)
